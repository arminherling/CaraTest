# CaraTest

[![AllInOne](https://github.com/arminherling/CaraTest/actions/workflows/all-in-one.yaml/badge.svg)](https://github.com/arminherling/CaraTest/actions/workflows/all-in-one.yaml)

## Description
Very basic test framework that I made for [Caracal](https://github.com/arminherling/Caracal), because QTest didn't support printing the combined results of multiple TestSuits without ugly hacks.


## Features
- Combined result of multiple test suits
- Snapshot tests 
- Snapshot tool for accepting or rejecting snapshots
- Parameterized tests
- Pretty console output (currently only works on Windows)

- 
## Usage
To use CaraTest, you need to include the `CaraTest.h` header file in your project. 
The library is designed to be used with C++ and provides a simple interface for defining and running tests.
```cpp
#include "CaraTest.h"
```


## Test Functions
CaraTest provides a set of functions for verifying conditions in your unit tests. 
When a test fails, these functions generate a detailed error message, including the source code location (using std::source_location).

### Fail
```cpp
CaraTest::Fail();
```
CaraTest provides a set of functions for verifying conditions in your unit tests. 
When a test fails, these functions generate a detailed error message, including the source code location (using std::source_location).

### Skip
```cpp
CaraTest::Skip();
```
Skips the execution of the current test.

### IsTrue
```cpp
CaraTest::IsTrue(value);
```
Checks if the given value is true. If the value is false, the test fails.

### IsFalse
```cpp
CaraTest::IsFalse(value);
```
Checks if the given value is false. If the value is true, the test fails.

### AreEqual
```cpp
CaraTest::AreEqual(expected, actual);
```
Checks if the expected value is equal to the actual value. 
If they are not equal, the test fails and an error message is generated.

### EqualsFile
```cpp
CaraTest::AreEqual(snapshotFilePath, actual);
```
Checks if the contents of the file at `snapshotFilePath` are equal to the actual value. 
If they are not equal, the test fails and a .snapshot file is generated.


## Macro
```cpp
CARATEST_TRIGGER_BREAK_ON_MATCH(firstValue, secondValue);
```
This macro is used to trigger a debug break when the first value matches the second value. 
It is useful for debugging tests where you want to inspect the values at a specific point in the code.


## Stringify
The error messages generated by CaraTest are automatically stringified using the `CaraTest::Stringify` function.
For example, if you pass a `bool` to the `AreEqual` function, it will be automatically converted to a string representation.
To support custom types, you can implement the `Stringify` function for your type.
```cpp
enum class TokenKind
{
    Plus,
    Minus,
    ...
};

QString Stringify(TokenKind kind)
{
    switch (kind)
    {
        case TokenKind::Plus:
            return QString("Plus");
        case TokenKind::Minus:
            return QString("Minus");
        ...
    }
}
```
Make sure to include the header where you define the `Stringify` function in your test file, so that CaraTest can find it when generating error messages.
The following types are already supported by CaraTest:
- `bool`
- `int`
- `long long`
- `const char*`
- `QString`
- `QStringView`
- `std::string`
- `std::chrono::nanoseconds`
- `std::tuple`


## Snapshot tool
`CaraTestSnapshotTool` can be used to accept or reject snapshots. 
The tool uses a file watcher to automatically update the list of snapshots when files are added or removed.
For the tool to work, you need to have to select the directory where the snapshots are generated. 
The tool will then show all snapshots in that directory, allowing you to choose to accept or reject each snapshot.


## Commandline parameters
The library currently has 2 commandline parameters to make debugging tests easier.

- ``break_on_fail`` 

This parameter triggers a debug break inside the AreEqual function. 
This allows us to inspect the parameters and we can go up the callstack into the failing test.
- ``break_and_rerun_on_fail``

This parameter triggers a debug break in the catch statement of the failed function and runs the test again. 
This allows us to step through the whole test again. 
